// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		Genesis
		Tx
		TxPayload
		Account
		TxSend
		Datacenter
		Datacenters
		TxCreateDatacenter
		ResourceUnit
		ResourceGroup
		ProviderAttribute
		DeploymentGroup
		Deployment
		Deployments
		TxDeployment
		DeploymentOrder
		DeploymentOrders
		FulfillmentOrder
		Lease
*/
package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_ovrclk_photon_types_base "github.com/ovrclk/photon/types/base"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Deployment_DeploymentState int32

const (
	Deployment_OPEN    Deployment_DeploymentState = 0
	Deployment_ORDERED Deployment_DeploymentState = 1
	Deployment_CLOSED  Deployment_DeploymentState = 2
)

var Deployment_DeploymentState_name = map[int32]string{
	0: "OPEN",
	1: "ORDERED",
	2: "CLOSED",
}
var Deployment_DeploymentState_value = map[string]int32{
	"OPEN":    0,
	"ORDERED": 1,
	"CLOSED":  2,
}

func (x Deployment_DeploymentState) String() string {
	return proto.EnumName(Deployment_DeploymentState_name, int32(x))
}
func (Deployment_DeploymentState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{12, 0}
}

type DeploymentOrder_DeploymentOrderState int32

const (
	DeploymentOrder_OPEN    DeploymentOrder_DeploymentOrderState = 0
	DeploymentOrder_MATCHED DeploymentOrder_DeploymentOrderState = 1
	DeploymentOrder_CLOSED  DeploymentOrder_DeploymentOrderState = 2
)

var DeploymentOrder_DeploymentOrderState_name = map[int32]string{
	0: "OPEN",
	1: "MATCHED",
	2: "CLOSED",
}
var DeploymentOrder_DeploymentOrderState_value = map[string]int32{
	"OPEN":    0,
	"MATCHED": 1,
	"CLOSED":  2,
}

func (x DeploymentOrder_DeploymentOrderState) String() string {
	return proto.EnumName(DeploymentOrder_DeploymentOrderState_name, int32(x))
}
func (DeploymentOrder_DeploymentOrderState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{15, 0}
}

// BEGIN GLOBAL
type Genesis struct {
	Accounts []Account `protobuf:"bytes,1,rep,name=accounts" json:"accounts"`
}

func (m *Genesis) Reset()                    { *m = Genesis{} }
func (m *Genesis) String() string            { return proto.CompactTextString(m) }
func (*Genesis) ProtoMessage()               {}
func (*Genesis) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Genesis) GetAccounts() []Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type Tx struct {
	Key       *github_com_ovrclk_photon_types_base.PubKey    `protobuf:"bytes,1,opt,name=key,proto3,customtype=github.com/ovrclk/photon/types/base.PubKey" json:"key,omitempty"`
	Signature *github_com_ovrclk_photon_types_base.Signature `protobuf:"bytes,2,opt,name=signature,proto3,customtype=github.com/ovrclk/photon/types/base.Signature" json:"signature,omitempty"`
	Payload   TxPayload                                      `protobuf:"bytes,3,opt,name=payload" json:"payload"`
}

func (m *Tx) Reset()                    { *m = Tx{} }
func (m *Tx) String() string            { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()               {}
func (*Tx) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *Tx) GetPayload() TxPayload {
	if m != nil {
		return m.Payload
	}
	return TxPayload{}
}

type TxPayload struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Types that are valid to be assigned to Payload:
	//	*TxPayload_TxSend
	//	*TxPayload_TxDeployment
	//	*TxPayload_TxCreateDatacenter
	Payload isTxPayload_Payload `protobuf_oneof:"payload"`
}

func (m *TxPayload) Reset()                    { *m = TxPayload{} }
func (m *TxPayload) String() string            { return proto.CompactTextString(m) }
func (*TxPayload) ProtoMessage()               {}
func (*TxPayload) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isTxPayload_Payload interface {
	isTxPayload_Payload()
}

type TxPayload_TxSend struct {
	TxSend *TxSend `protobuf:"bytes,2,opt,name=txSend,oneof"`
}
type TxPayload_TxDeployment struct {
	TxDeployment *TxDeployment `protobuf:"bytes,3,opt,name=txDeployment,oneof"`
}
type TxPayload_TxCreateDatacenter struct {
	TxCreateDatacenter *TxCreateDatacenter `protobuf:"bytes,4,opt,name=txCreateDatacenter,oneof"`
}

func (*TxPayload_TxSend) isTxPayload_Payload()             {}
func (*TxPayload_TxDeployment) isTxPayload_Payload()       {}
func (*TxPayload_TxCreateDatacenter) isTxPayload_Payload() {}

func (m *TxPayload) GetPayload() isTxPayload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TxPayload) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *TxPayload) GetTxSend() *TxSend {
	if x, ok := m.GetPayload().(*TxPayload_TxSend); ok {
		return x.TxSend
	}
	return nil
}

func (m *TxPayload) GetTxDeployment() *TxDeployment {
	if x, ok := m.GetPayload().(*TxPayload_TxDeployment); ok {
		return x.TxDeployment
	}
	return nil
}

func (m *TxPayload) GetTxCreateDatacenter() *TxCreateDatacenter {
	if x, ok := m.GetPayload().(*TxPayload_TxCreateDatacenter); ok {
		return x.TxCreateDatacenter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TxPayload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TxPayload_OneofMarshaler, _TxPayload_OneofUnmarshaler, _TxPayload_OneofSizer, []interface{}{
		(*TxPayload_TxSend)(nil),
		(*TxPayload_TxDeployment)(nil),
		(*TxPayload_TxCreateDatacenter)(nil),
	}
}

func _TxPayload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TxPayload)
	// payload
	switch x := m.Payload.(type) {
	case *TxPayload_TxSend:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TxSend); err != nil {
			return err
		}
	case *TxPayload_TxDeployment:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TxDeployment); err != nil {
			return err
		}
	case *TxPayload_TxCreateDatacenter:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TxCreateDatacenter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TxPayload.Payload has unexpected type %T", x)
	}
	return nil
}

func _TxPayload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TxPayload)
	switch tag {
	case 2: // payload.txSend
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TxSend)
		err := b.DecodeMessage(msg)
		m.Payload = &TxPayload_TxSend{msg}
		return true, err
	case 3: // payload.txDeployment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TxDeployment)
		err := b.DecodeMessage(msg)
		m.Payload = &TxPayload_TxDeployment{msg}
		return true, err
	case 4: // payload.txCreateDatacenter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TxCreateDatacenter)
		err := b.DecodeMessage(msg)
		m.Payload = &TxPayload_TxCreateDatacenter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TxPayload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TxPayload)
	// payload
	switch x := m.Payload.(type) {
	case *TxPayload_TxSend:
		s := proto.Size(x.TxSend)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxPayload_TxDeployment:
		s := proto.Size(x.TxDeployment)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxPayload_TxCreateDatacenter:
		s := proto.Size(x.TxCreateDatacenter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BEGIN ACCOUNT
type Account struct {
	Address github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=address,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"address"`
	Balance uint64                                    `protobuf:"varint,2,opt,name=balance,proto3" json:"balance,omitempty"`
	Nonce   uint64                                    `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *Account) Reset()                    { *m = Account{} }
func (m *Account) String() string            { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()               {}
func (*Account) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *Account) GetBalance() uint64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type TxSend struct {
	From   github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=from,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"from"`
	To     github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,2,opt,name=to,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"to"`
	Amount uint64                                    `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TxSend) Reset()                    { *m = TxSend{} }
func (m *TxSend) String() string            { return proto.CompactTextString(m) }
func (*TxSend) ProtoMessage()               {}
func (*TxSend) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *TxSend) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type Datacenter struct {
	Address    github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=address,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"address"`
	Owner      github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,2,opt,name=owner,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"owner"`
	Attributes []ProviderAttribute                       `protobuf:"bytes,3,rep,name=attributes" json:"attributes"`
	Resources  []ResourceGroup                           `protobuf:"bytes,4,rep,name=resources" json:"resources"`
}

func (m *Datacenter) Reset()                    { *m = Datacenter{} }
func (m *Datacenter) String() string            { return proto.CompactTextString(m) }
func (*Datacenter) ProtoMessage()               {}
func (*Datacenter) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *Datacenter) GetAttributes() []ProviderAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Datacenter) GetResources() []ResourceGroup {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Datacenters struct {
	Datacenters []Datacenter `protobuf:"bytes,1,rep,name=datacenters" json:"datacenters"`
}

func (m *Datacenters) Reset()                    { *m = Datacenters{} }
func (m *Datacenters) String() string            { return proto.CompactTextString(m) }
func (*Datacenters) ProtoMessage()               {}
func (*Datacenters) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *Datacenters) GetDatacenters() []Datacenter {
	if m != nil {
		return m.Datacenters
	}
	return nil
}

type TxCreateDatacenter struct {
	Datacenter Datacenter `protobuf:"bytes,1,opt,name=datacenter" json:"datacenter"`
}

func (m *TxCreateDatacenter) Reset()                    { *m = TxCreateDatacenter{} }
func (m *TxCreateDatacenter) String() string            { return proto.CompactTextString(m) }
func (*TxCreateDatacenter) ProtoMessage()               {}
func (*TxCreateDatacenter) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *TxCreateDatacenter) GetDatacenter() Datacenter {
	if m != nil {
		return m.Datacenter
	}
	return Datacenter{}
}

// BEGIN EXCHANGE
type ResourceUnit struct {
	Cpu    uint32 `protobuf:"varint,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory uint32 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	Disk   uint64 `protobuf:"varint,3,opt,name=disk,proto3" json:"disk,omitempty"`
}

func (m *ResourceUnit) Reset()                    { *m = ResourceUnit{} }
func (m *ResourceUnit) String() string            { return proto.CompactTextString(m) }
func (*ResourceUnit) ProtoMessage()               {}
func (*ResourceUnit) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *ResourceUnit) GetCpu() uint32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *ResourceUnit) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ResourceUnit) GetDisk() uint64 {
	if m != nil {
		return m.Disk
	}
	return 0
}

type ResourceGroup struct {
	Unit  ResourceUnit `protobuf:"bytes,1,opt,name=unit" json:"unit"`
	Count uint32       `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Price uint32       `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *ResourceGroup) Reset()                    { *m = ResourceGroup{} }
func (m *ResourceGroup) String() string            { return proto.CompactTextString(m) }
func (*ResourceGroup) ProtoMessage()               {}
func (*ResourceGroup) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *ResourceGroup) GetUnit() ResourceUnit {
	if m != nil {
		return m.Unit
	}
	return ResourceUnit{}
}

func (m *ResourceGroup) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ResourceGroup) GetPrice() uint32 {
	if m != nil {
		return m.Price
	}
	return 0
}

type ProviderAttribute struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ProviderAttribute) Reset()                    { *m = ProviderAttribute{} }
func (m *ProviderAttribute) String() string            { return proto.CompactTextString(m) }
func (*ProviderAttribute) ProtoMessage()               {}
func (*ProviderAttribute) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *ProviderAttribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProviderAttribute) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DeploymentGroup struct {
	Requirements []ProviderAttribute `protobuf:"bytes,1,rep,name=requirements" json:"requirements"`
	Resources    []ResourceGroup     `protobuf:"bytes,2,rep,name=resources" json:"resources"`
}

func (m *DeploymentGroup) Reset()                    { *m = DeploymentGroup{} }
func (m *DeploymentGroup) String() string            { return proto.CompactTextString(m) }
func (*DeploymentGroup) ProtoMessage()               {}
func (*DeploymentGroup) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *DeploymentGroup) GetRequirements() []ProviderAttribute {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *DeploymentGroup) GetResources() []ResourceGroup {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Deployment struct {
	Address github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=address,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"address"`
	From    github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,2,opt,name=from,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"from"`
	Groups  []DeploymentGroup                         `protobuf:"bytes,3,rep,name=groups" json:"groups"`
	State   Deployment_DeploymentState                `protobuf:"varint,4,opt,name=state,proto3,enum=types.Deployment_DeploymentState" json:"state,omitempty"`
	Nonce   uint64                                    `protobuf:"varint,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *Deployment) Reset()                    { *m = Deployment{} }
func (m *Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()               {}
func (*Deployment) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *Deployment) GetGroups() []DeploymentGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *Deployment) GetState() Deployment_DeploymentState {
	if m != nil {
		return m.State
	}
	return Deployment_OPEN
}

func (m *Deployment) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type Deployments struct {
	Deployments []Deployment `protobuf:"bytes,1,rep,name=deployments" json:"deployments"`
}

func (m *Deployments) Reset()                    { *m = Deployments{} }
func (m *Deployments) String() string            { return proto.CompactTextString(m) }
func (*Deployments) ProtoMessage()               {}
func (*Deployments) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *Deployments) GetDeployments() []Deployment {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type TxDeployment struct {
	From       github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=from,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"from"`
	Deployment *Deployment                               `protobuf:"bytes,2,opt,name=deployment" json:"deployment,omitempty"`
}

func (m *TxDeployment) Reset()                    { *m = TxDeployment{} }
func (m *TxDeployment) String() string            { return proto.CompactTextString(m) }
func (*TxDeployment) ProtoMessage()               {}
func (*TxDeployment) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *TxDeployment) GetDeployment() *Deployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

type DeploymentOrder struct {
	Address    github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,1,opt,name=address,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"address"`
	From       github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,2,opt,name=from,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"from"`
	Deployment github_com_ovrclk_photon_types_base.Bytes `protobuf:"bytes,3,opt,name=deployment,proto3,customtype=github.com/ovrclk/photon/types/base.Bytes" json:"deployment"`
	Groups     []DeploymentGroup                         `protobuf:"bytes,4,rep,name=groups" json:"groups"`
	State      DeploymentOrder_DeploymentOrderState      `protobuf:"varint,5,opt,name=state,proto3,enum=types.DeploymentOrder_DeploymentOrderState" json:"state,omitempty"`
}

func (m *DeploymentOrder) Reset()                    { *m = DeploymentOrder{} }
func (m *DeploymentOrder) String() string            { return proto.CompactTextString(m) }
func (*DeploymentOrder) ProtoMessage()               {}
func (*DeploymentOrder) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *DeploymentOrder) GetGroups() []DeploymentGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *DeploymentOrder) GetState() DeploymentOrder_DeploymentOrderState {
	if m != nil {
		return m.State
	}
	return DeploymentOrder_OPEN
}

type DeploymentOrders struct {
	DeploymentOrders []DeploymentOrder `protobuf:"bytes,1,rep,name=deploymentOrders" json:"deploymentOrders"`
}

func (m *DeploymentOrders) Reset()                    { *m = DeploymentOrders{} }
func (m *DeploymentOrders) String() string            { return proto.CompactTextString(m) }
func (*DeploymentOrders) ProtoMessage()               {}
func (*DeploymentOrders) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *DeploymentOrders) GetDeploymentOrders() []DeploymentOrder {
	if m != nil {
		return m.DeploymentOrders
	}
	return nil
}

type FulfillmentOrder struct {
	Deployment string          `protobuf:"bytes,1,opt,name=deployment,proto3" json:"deployment,omitempty"`
	Group      uint32          `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Provider   string          `protobuf:"bytes,3,opt,name=provider,proto3" json:"provider,omitempty"`
	Resources  []ResourceGroup `protobuf:"bytes,4,rep,name=resources" json:"resources"`
}

func (m *FulfillmentOrder) Reset()                    { *m = FulfillmentOrder{} }
func (m *FulfillmentOrder) String() string            { return proto.CompactTextString(m) }
func (*FulfillmentOrder) ProtoMessage()               {}
func (*FulfillmentOrder) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *FulfillmentOrder) GetDeployment() string {
	if m != nil {
		return m.Deployment
	}
	return ""
}

func (m *FulfillmentOrder) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *FulfillmentOrder) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *FulfillmentOrder) GetResources() []ResourceGroup {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Lease struct {
	Deployment string `protobuf:"bytes,1,opt,name=deployment,proto3" json:"deployment,omitempty"`
	Group      uint32 `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Order      uint32 `protobuf:"varint,3,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (m *Lease) String() string            { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *Lease) GetDeployment() string {
	if m != nil {
		return m.Deployment
	}
	return ""
}

func (m *Lease) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Lease) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func init() {
	proto.RegisterType((*Genesis)(nil), "types.Genesis")
	proto.RegisterType((*Tx)(nil), "types.Tx")
	proto.RegisterType((*TxPayload)(nil), "types.TxPayload")
	proto.RegisterType((*Account)(nil), "types.Account")
	proto.RegisterType((*TxSend)(nil), "types.TxSend")
	proto.RegisterType((*Datacenter)(nil), "types.Datacenter")
	proto.RegisterType((*Datacenters)(nil), "types.Datacenters")
	proto.RegisterType((*TxCreateDatacenter)(nil), "types.TxCreateDatacenter")
	proto.RegisterType((*ResourceUnit)(nil), "types.ResourceUnit")
	proto.RegisterType((*ResourceGroup)(nil), "types.ResourceGroup")
	proto.RegisterType((*ProviderAttribute)(nil), "types.ProviderAttribute")
	proto.RegisterType((*DeploymentGroup)(nil), "types.DeploymentGroup")
	proto.RegisterType((*Deployment)(nil), "types.Deployment")
	proto.RegisterType((*Deployments)(nil), "types.Deployments")
	proto.RegisterType((*TxDeployment)(nil), "types.TxDeployment")
	proto.RegisterType((*DeploymentOrder)(nil), "types.DeploymentOrder")
	proto.RegisterType((*DeploymentOrders)(nil), "types.DeploymentOrders")
	proto.RegisterType((*FulfillmentOrder)(nil), "types.FulfillmentOrder")
	proto.RegisterType((*Lease)(nil), "types.Lease")
	proto.RegisterEnum("types.Deployment_DeploymentState", Deployment_DeploymentState_name, Deployment_DeploymentState_value)
	proto.RegisterEnum("types.DeploymentOrder_DeploymentOrderState", DeploymentOrder_DeploymentOrderState_name, DeploymentOrder_DeploymentOrderState_value)
}
func (this *Genesis) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.Genesis{")
	if this.Accounts != nil {
		vs := make([]*Account, len(this.Accounts))
		for i := range vs {
			vs[i] = &this.Accounts[i]
		}
		s = append(s, "Accounts: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tx) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.Tx{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "Payload: "+strings.Replace(this.Payload.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxPayload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.TxPayload{")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	if this.Payload != nil {
		s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxPayload_TxSend) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.TxPayload_TxSend{` +
		`TxSend:` + fmt.Sprintf("%#v", this.TxSend) + `}`}, ", ")
	return s
}
func (this *TxPayload_TxDeployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.TxPayload_TxDeployment{` +
		`TxDeployment:` + fmt.Sprintf("%#v", this.TxDeployment) + `}`}, ", ")
	return s
}
func (this *TxPayload_TxCreateDatacenter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.TxPayload_TxCreateDatacenter{` +
		`TxCreateDatacenter:` + fmt.Sprintf("%#v", this.TxCreateDatacenter) + `}`}, ", ")
	return s
}
func (this *Account) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.Account{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxSend) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.TxSend{")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Datacenter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.Datacenter{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Owner: "+fmt.Sprintf("%#v", this.Owner)+",\n")
	if this.Attributes != nil {
		vs := make([]*ProviderAttribute, len(this.Attributes))
		for i := range vs {
			vs[i] = &this.Attributes[i]
		}
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Resources != nil {
		vs := make([]*ResourceGroup, len(this.Resources))
		for i := range vs {
			vs[i] = &this.Resources[i]
		}
		s = append(s, "Resources: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Datacenters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.Datacenters{")
	if this.Datacenters != nil {
		vs := make([]*Datacenter, len(this.Datacenters))
		for i := range vs {
			vs[i] = &this.Datacenters[i]
		}
		s = append(s, "Datacenters: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxCreateDatacenter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.TxCreateDatacenter{")
	s = append(s, "Datacenter: "+strings.Replace(this.Datacenter.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceUnit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.ResourceUnit{")
	s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Disk: "+fmt.Sprintf("%#v", this.Disk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.ResourceGroup{")
	s = append(s, "Unit: "+strings.Replace(this.Unit.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderAttribute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.ProviderAttribute{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeploymentGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.DeploymentGroup{")
	if this.Requirements != nil {
		vs := make([]*ProviderAttribute, len(this.Requirements))
		for i := range vs {
			vs[i] = &this.Requirements[i]
		}
		s = append(s, "Requirements: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Resources != nil {
		vs := make([]*ResourceGroup, len(this.Resources))
		for i := range vs {
			vs[i] = &this.Resources[i]
		}
		s = append(s, "Resources: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Deployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.Deployment{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	if this.Groups != nil {
		vs := make([]*DeploymentGroup, len(this.Groups))
		for i := range vs {
			vs[i] = &this.Groups[i]
		}
		s = append(s, "Groups: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Deployments) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.Deployments{")
	if this.Deployments != nil {
		vs := make([]*Deployment, len(this.Deployments))
		for i := range vs {
			vs[i] = &this.Deployments[i]
		}
		s = append(s, "Deployments: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxDeployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.TxDeployment{")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	if this.Deployment != nil {
		s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeploymentOrder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.DeploymentOrder{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	if this.Groups != nil {
		vs := make([]*DeploymentGroup, len(this.Groups))
		for i := range vs {
			vs[i] = &this.Groups[i]
		}
		s = append(s, "Groups: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeploymentOrders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.DeploymentOrders{")
	if this.DeploymentOrders != nil {
		vs := make([]*DeploymentOrder, len(this.DeploymentOrders))
		for i := range vs {
			vs[i] = &this.DeploymentOrders[i]
		}
		s = append(s, "DeploymentOrders: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FulfillmentOrder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.FulfillmentOrder{")
	s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	if this.Resources != nil {
		vs := make([]*ResourceGroup, len(this.Resources))
		for i := range vs {
			vs[i] = &this.Resources[i]
		}
		s = append(s, "Resources: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Lease) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.Lease{")
	s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Genesis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Genesis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Genesis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, Account{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_ovrclk_photon_types_base.PubKey
			m.Key = &v
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_ovrclk_photon_types_base.Signature
			m.Signature = &v
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TxSend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &TxPayload_TxSend{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDeployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TxDeployment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &TxPayload_TxDeployment{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCreateDatacenter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TxCreateDatacenter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &TxPayload_TxCreateDatacenter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datacenter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datacenter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datacenter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, ProviderAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, ResourceGroup{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datacenters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datacenters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datacenters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenters = append(m.Datacenters, Datacenter{})
			if err := m.Datacenters[len(m.Datacenters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCreateDatacenter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCreateDatacenter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCreateDatacenter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Datacenter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, ProviderAttribute{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, ResourceGroup{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, DeploymentGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (Deployment_DeploymentState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployments = append(m.Deployments, Deployment{})
			if err := m.Deployments[len(m.Deployments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &Deployment{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, DeploymentGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DeploymentOrder_DeploymentOrderState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentOrders = append(m.DeploymentOrders, DeploymentOrder{})
			if err := m.DeploymentOrders[len(m.DeploymentOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FulfillmentOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FulfillmentOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FulfillmentOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, ResourceGroup{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1005 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xf6, 0xfa, 0x37, 0x3e, 0xb6, 0x8b, 0x33, 0xb5, 0xa2, 0xa5, 0x17, 0x4e, 0xd8, 0x1b, 0x02,
	0x28, 0x76, 0x13, 0x2a, 0x95, 0x08, 0x81, 0xb0, 0x63, 0x13, 0x4b, 0x49, 0x71, 0x18, 0x87, 0x3b,
	0x6e, 0xd6, 0xde, 0x89, 0xbb, 0xc4, 0xde, 0x59, 0x66, 0x67, 0x83, 0xfd, 0x02, 0x88, 0x3b, 0x5e,
	0x00, 0xf1, 0x00, 0x88, 0x07, 0x81, 0x3b, 0x2e, 0xab, 0x20, 0x22, 0xb5, 0x4f, 0xc0, 0x23, 0xa0,
	0x9d, 0x99, 0xfd, 0xb1, 0x1d, 0xd1, 0x26, 0xf5, 0x4d, 0x34, 0x67, 0xe6, 0x7c, 0x67, 0xbf, 0xf9,
	0xe6, 0x3b, 0xc7, 0x81, 0x4d, 0x3e, 0x77, 0x89, 0xd7, 0x14, 0x7f, 0x1b, 0x2e, 0xa3, 0x9c, 0xa2,
	0x9c, 0x08, 0x1e, 0xed, 0x8d, 0x6d, 0xfe, 0xdc, 0x1f, 0x36, 0x46, 0x74, 0xda, 0x1c, 0xd3, 0x31,
	0x6d, 0x8a, 0xd3, 0xa1, 0x7f, 0x21, 0x22, 0x11, 0x88, 0x95, 0x44, 0x19, 0x9f, 0x42, 0xe1, 0x98,
	0x38, 0xc4, 0xb3, 0x3d, 0xf4, 0x18, 0x36, 0xcc, 0xd1, 0x88, 0xfa, 0x0e, 0xf7, 0x74, 0x6d, 0x27,
	0xb3, 0x5b, 0x3a, 0x78, 0xd0, 0x90, 0x1f, 0x68, 0xc9, 0xed, 0x76, 0xf6, 0x8f, 0x9b, 0xed, 0x14,
	0x8e, 0xb2, 0x8c, 0x3f, 0x35, 0x48, 0x9f, 0xcf, 0xd0, 0x17, 0x90, 0xb9, 0x24, 0x73, 0x5d, 0xdb,
	0xd1, 0x76, 0xcb, 0xed, 0xc6, 0xf5, 0xcd, 0xf6, 0x87, 0x09, 0x0e, 0xf4, 0x8a, 0x8d, 0x26, 0x97,
	0x4d, 0xf7, 0x39, 0xe5, 0xd4, 0x91, 0x84, 0x9b, 0x43, 0xd3, 0x23, 0x8d, 0x33, 0x7f, 0x78, 0x42,
	0xe6, 0x38, 0x80, 0xa2, 0x3e, 0x14, 0x3d, 0x7b, 0xec, 0x98, 0xdc, 0x67, 0x44, 0x4f, 0x8b, 0x3a,
	0xfb, 0xd7, 0x37, 0xdb, 0x7b, 0x6f, 0x52, 0x67, 0x10, 0x02, 0x71, 0x5c, 0x03, 0x3d, 0x86, 0x82,
	0x6b, 0xce, 0x27, 0xd4, 0xb4, 0xf4, 0xcc, 0x8e, 0xb6, 0x5b, 0x3a, 0xa8, 0xaa, 0xab, 0x9c, 0xcf,
	0xce, 0xe4, 0xbe, 0xba, 0x4c, 0x98, 0x66, 0xfc, 0xa3, 0x41, 0x31, 0x3a, 0x44, 0x35, 0xc8, 0x39,
	0xd4, 0x19, 0x11, 0x71, 0xa9, 0x2c, 0x96, 0x01, 0x7a, 0x1f, 0xf2, 0x7c, 0x36, 0x20, 0x8e, 0x25,
	0x38, 0x96, 0x0e, 0x2a, 0x51, 0xd1, 0x60, 0xb3, 0x97, 0xc2, 0xea, 0x18, 0x1d, 0x42, 0x99, 0xcf,
	0x3a, 0xc4, 0x9d, 0xd0, 0xf9, 0x94, 0x38, 0x5c, 0x71, 0x78, 0x18, 0xa5, 0xc7, 0x47, 0xbd, 0x14,
	0x5e, 0x48, 0x45, 0x27, 0x80, 0xf8, 0xec, 0x88, 0x11, 0x93, 0x93, 0x8e, 0xc9, 0xcd, 0x11, 0x71,
	0x38, 0x61, 0x7a, 0x56, 0x14, 0x78, 0x37, 0x2a, 0xb0, 0x9c, 0xd0, 0x4b, 0xe1, 0x5b, 0x60, 0xed,
	0x62, 0x24, 0x83, 0xf1, 0xa3, 0x06, 0x05, 0xf5, 0x8e, 0xe8, 0x04, 0x0a, 0xa6, 0x65, 0x31, 0xe2,
	0x79, 0xea, 0xd1, 0xf6, 0x03, 0x2d, 0xae, 0x6f, 0xb6, 0x3f, 0x78, 0x13, 0xc1, 0xdb, 0x73, 0x4e,
	0x3c, 0x1c, 0x56, 0x40, 0x3a, 0x14, 0x86, 0xe6, 0xc4, 0x0c, 0xc4, 0x4a, 0x0b, 0xb1, 0xc2, 0x30,
	0x16, 0x31, 0x93, 0x10, 0xd1, 0xf8, 0x4d, 0x83, 0xbc, 0x14, 0x0c, 0x75, 0x21, 0x7b, 0xc1, 0xe8,
	0xf4, 0xfe, 0x24, 0x04, 0x1c, 0xb5, 0x20, 0xcd, 0x69, 0x68, 0x9b, 0xbb, 0x17, 0x49, 0x73, 0x8a,
	0xb6, 0x20, 0x6f, 0x4e, 0x03, 0x6d, 0x14, 0x57, 0x15, 0x19, 0xbf, 0xa4, 0x01, 0x62, 0x3d, 0xd7,
	0x2b, 0xdc, 0x31, 0xe4, 0xe8, 0x0f, 0x0e, 0x61, 0xf7, 0x67, 0x2e, 0xf1, 0xe8, 0x73, 0x00, 0x93,
	0x73, 0x66, 0x0f, 0x7d, 0x4e, 0x3c, 0x3d, 0x23, 0x5a, 0x57, 0x57, 0x56, 0x39, 0x63, 0xf4, 0xca,
	0xb6, 0x08, 0x6b, 0x85, 0x09, 0xca, 0xf7, 0x09, 0x04, 0xfa, 0x04, 0x8a, 0x8c, 0x78, 0xd4, 0x67,
	0x23, 0xe2, 0xe9, 0x59, 0x01, 0xaf, 0x29, 0x38, 0x56, 0xfb, 0xc7, 0x8c, 0xfa, 0xae, 0x82, 0xc6,
	0xc9, 0x46, 0x0f, 0x4a, 0xb1, 0x3a, 0x1e, 0x3a, 0x84, 0x92, 0x15, 0x87, 0x6a, 0x88, 0x6c, 0xaa,
	0x52, 0x09, 0x5b, 0xca, 0x3a, 0xc9, 0x5c, 0xe3, 0x19, 0xa0, 0x55, 0x57, 0xa3, 0xa7, 0x00, 0x71,
	0x92, 0x90, 0xfc, 0x7f, 0xea, 0x25, 0x52, 0x8d, 0x53, 0x28, 0x87, 0xd4, 0xbf, 0x71, 0x6c, 0x8e,
	0xaa, 0x90, 0x19, 0xb9, 0xbe, 0xa8, 0x50, 0xc1, 0xc1, 0x32, 0x78, 0xf1, 0x29, 0x99, 0x52, 0x36,
	0x17, 0xf2, 0x57, 0xb0, 0x8a, 0x10, 0x82, 0xac, 0x65, 0x7b, 0x97, 0xca, 0x07, 0x62, 0x6d, 0x7c,
	0x07, 0x95, 0x05, 0x21, 0xd0, 0x1e, 0x64, 0x7d, 0xc7, 0xe6, 0x8a, 0xd1, 0xc3, 0x25, 0xb1, 0x82,
	0x2f, 0x2a, 0x4e, 0x22, 0x2d, 0x68, 0x04, 0xd1, 0x78, 0xea, 0x53, 0x32, 0x08, 0x76, 0x5d, 0x66,
	0xab, 0xf6, 0xa8, 0x60, 0x19, 0x18, 0x9f, 0xc1, 0xe6, 0xca, 0x9b, 0x05, 0xa4, 0x1c, 0x73, 0x2a,
	0xa7, 0x51, 0x11, 0x8b, 0x75, 0x00, 0xbf, 0x32, 0x27, 0xbe, 0xec, 0xba, 0x22, 0x96, 0x81, 0xf1,
	0xb3, 0x06, 0xef, 0xc4, 0xd3, 0x44, 0xb2, 0x6d, 0x43, 0x99, 0x91, 0xef, 0x7d, 0x9b, 0x91, 0x60,
	0x2f, 0x7c, 0x97, 0xd7, 0x39, 0x64, 0x01, 0xb3, 0xe8, 0x91, 0xf4, 0x5d, 0x3c, 0xf2, 0x77, 0xd0,
	0x42, 0xc9, 0xf9, 0xb6, 0xc6, 0x16, 0x0a, 0x07, 0x48, 0xfa, 0xed, 0x06, 0xc8, 0x13, 0xc8, 0x8f,
	0x03, 0xf2, 0x61, 0xf3, 0x6c, 0x85, 0x16, 0x5b, 0x14, 0x52, 0xdd, 0x4d, 0xe5, 0xa2, 0xa7, 0x90,
	0xf3, 0xb8, 0xc9, 0x89, 0x18, 0xce, 0x0f, 0x0e, 0xde, 0x5b, 0x01, 0x25, 0x96, 0x83, 0x20, 0x11,
	0xcb, 0xfc, 0x78, 0x2e, 0xe6, 0x92, 0x73, 0xf1, 0x49, 0xf2, 0xe1, 0x44, 0x3e, 0xda, 0x80, 0x6c,
	0xff, 0xac, 0xfb, 0x55, 0x35, 0x85, 0x4a, 0x50, 0xe8, 0xe3, 0x4e, 0x17, 0x77, 0x3b, 0x55, 0x0d,
	0x01, 0xe4, 0x8f, 0x4e, 0xfb, 0x83, 0x6e, 0xa7, 0x9a, 0x16, 0x1d, 0x18, 0xa1, 0x64, 0x07, 0xc6,
	0xe1, 0x72, 0x07, 0x46, 0x27, 0x51, 0x07, 0xc6, 0xb9, 0xc6, 0x4f, 0x1a, 0x94, 0x93, 0xbf, 0x4c,
	0xeb, 0x9a, 0xce, 0xfb, 0x00, 0xf1, 0x67, 0xd4, 0x0f, 0xe7, 0x2a, 0x23, 0x9c, 0x48, 0x32, 0x7e,
	0xcf, 0x24, 0xb5, 0xe8, 0x33, 0x6b, 0xdd, 0xa3, 0x77, 0x4d, 0xbe, 0xf9, 0x7a, 0xe1, 0x6a, 0x99,
	0xfb, 0x16, 0x4b, 0x14, 0x49, 0x58, 0x31, 0x7b, 0x07, 0x2b, 0xb6, 0x42, 0x2b, 0xe6, 0x84, 0x15,
	0x3f, 0x5a, 0x01, 0x09, 0x0d, 0x97, 0xe3, 0xa4, 0x29, 0x8d, 0x43, 0xa8, 0xdd, 0x76, 0xbc, 0xe8,
	0xc1, 0x67, 0xad, 0xf3, 0xa3, 0xde, 0x8a, 0x07, 0xbf, 0x85, 0xea, 0x12, 0xd4, 0x43, 0x3d, 0xa8,
	0x5a, 0x4b, 0x7b, 0xca, 0x8d, 0x5b, 0xb7, 0x93, 0x53, 0x37, 0x5a, 0x41, 0x19, 0xbf, 0x6a, 0x50,
	0xfd, 0xd2, 0x9f, 0x5c, 0xd8, 0x93, 0x49, 0xec, 0x86, 0xfa, 0x82, 0xf2, 0x72, 0x2c, 0x26, 0x65,
	0xac, 0x41, 0x4e, 0x48, 0x13, 0x4e, 0x5c, 0x11, 0xa0, 0x47, 0xb0, 0xe1, 0xaa, 0x69, 0x27, 0x5e,
	0xab, 0x88, 0xa3, 0xf8, 0x2d, 0x7e, 0x04, 0x07, 0x90, 0x3b, 0x25, 0xa6, 0x47, 0xee, 0x49, 0xaa,
	0x06, 0x39, 0xca, 0x42, 0x46, 0x15, 0x2c, 0x83, 0x76, 0xf5, 0xc5, 0xcb, 0xba, 0xf6, 0xef, 0xcb,
	0xba, 0xf6, 0xd7, 0xab, 0xba, 0xf6, 0xe2, 0x55, 0x5d, 0x1b, 0xe6, 0xc5, 0x3f, 0xec, 0x1f, 0xff,
	0x17, 0x00, 0x00, 0xff, 0xff, 0x8f, 0xd0, 0x3b, 0xbe, 0xfb, 0x0b, 0x00, 0x00,
}
